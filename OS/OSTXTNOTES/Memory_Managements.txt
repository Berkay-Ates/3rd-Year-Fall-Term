For paging hardware support also required. 

PROGRAM ADDRESSES AND MEMORY 
- When code is generated we use memory addresses fo variables, functions and vranching/jumping 
- Those addresses can be physical or logical memory addresses 
- In very early systems they are just physical memory addresses 
- A program has to be loaded to that address to run (no replacements)


LOGICAL ADDRESS SPACE CONCEPT 
- We need logical address space concept, that is different that the physical RAM (main memory) addresses. 
- A programm uses logical addresses  
- Set of logical addresses used by the program is its logical address space 
	- Logical addresses space can be for example [0..max_address]
- Logical address space has to be mapped somewhere i physical memory

	0 -> corresponds to BASE REGISTER 
	Program Size -> corresponds to LIMIT REGISTER - BASE REGISTER
	LIMIT = max_Address


BINDING OF INSTRUCTIONS AND DATA TO MEMORY 
- Address binding of instructions and data to (physical) memory addresses can happen at three different stages. 

1- Compile Time: If memory location known a priori, absolute code can be generated, must recompile code if starting location changes.

2- Load Time: Must generate relocatable code if memory location is not known at compile time. 

3- Execution Time: Bindign deleayed until run time if the process can be moved during its execution from one memory segment to another. Need hardware support for address maps. 

program icinde sadece logical addressler vardir program hafizadan bir addrese erismek istediginde programda bulunan logical addresse base address eklenir ve bu addresin limit register degerinden kucuk olmasi beklenir. 

-> A pair of base and limit registers define the logical address space. 
 

LOGICAL vs PHYSICAL ADDRESS SPACE 
The concept of a logical address space that is bounded to a separate physical address space is central to proper memory management. 

-Logicall address- generated by the CPU, also referred to as vitual address 
- Physical address address seen by the memory 

Logical and physical addresses are the same in compile-time and load-time adddress binding schemes, logical (virtual) and physical addresses differ in execution time address-binding scheme. 


MEMORY-MANAGEMENT UNIT
- Hardware device that maps logical (virtual) to physical address
- In MMU acheme the value in the relocation register is added to every address generated by a user process at the time it is sent to memory. 
- The user program deals with logicall addresses it never sees the real physical addresses 


DYNAMIC LOADING 
- Routine is not loaded until it is called 
- Better memory-space utilization unused routine is never loaded 
- Useful when alrge amounts of code are needed to handle infrequently occurring cases 
- No special support from the operating system is required implemented through program design 


DYNAMIC LINKING 
- Linking postponed until execution time 
- Small piece of code STUB used to locate the appropriate memory resident library routine 
- STUB replaces itself with the address of the routine and executes the routine 
- OS needed to check if routine is in process' memory address 
- Dynamic linking is particularly useful for libaries
	- Standard C library is shared library that is dynamically inked not 	statically linked 
	- You can link statically if you want 
- System also known as SHARED LIBRARIES 


SWAPPING 
- A process can be swapped temporarily out of memory to a backing store and then brouhgt back into memory for continued execution
- BACKING STORE - fast disk large enough to accomodate copies of all memory images for all users, must provide direct access to these memory images. 
- ROLL OUT, ROLL In - swapping variant used for priority-baased scheduling algorithms; lower-priority process is swapped out so higher-priority process can be loaded and executed. 
- Major part of swap time is transer time; totoal transfer time is directly proportional to the amount of memory sawwed. 
- Modified versions of swapping are found on many systems Unix, Linux and Windows 
- System maintains a ready queue of ready-to-run processes which ahve memory images on disk. 


CONTIGUOUS ALLOCATION 
- Main memory is partioned usually into two partitions:
	-Resident operating system, usually held in low memory with interrupt 	vector
	-User processes then held in high memory 
- Relocation registers used to protect user processes from each other and from changeing operating system code and data
	- Base register contains value of smallest physical address
	- Limit register contains range of logicall addresses each logical address 	must be less than the limit register. 
	- MMU maps logical addresses dynamically 

MULTIPLE-PARTITION ALLOCATION 
- Hole-Block of avaliable memory, holes of various size are scattered throughout memory. 
- When a proces arrives it is allocated memory from a hole large enough to accomodate it 
- Operating system maintains information about 
	a) allocated partitons 
	b) free partitions (holes) 

DYNAMIC STORAGE-ALLOCATION PROBLEM 
How to satisfy a request of size n from a list of free holes 
- FIRST FIT: Allocate the first hole that is big enough 
- BEST-FIT: Allocate the smallest hole that is beig enough must search entire list unless ordered by size
	-Produces the smllest leftover hole 
- WORST-FIT: Allocate the largest hole, must also search entire list. 
	-Produes the largest leftover hole 

First-fit and Best-fit better than Worst-fit in terms of speed and sttorage utilization. 


FRAGMENTATION 
External Fragmentation: Total memory space exists to satisfy a request but it is not contiguous. 
Internal Fragmentation: Allocated memory may be slightly larger than requested memory this size difference is memory internal to a partition (allocation), but not being used. 

Reduce external fragmentatioon by COMPACTION
- Shuffle memory contants to place all free memory together in one large block
- Compaction is possible only if relocation is dynamic, and is done at execution time. 
- I/o problem 
	- Latch job in memory while it is involved in I/O
	- Do I/O only into OS buffers 


PAGING 
- Logical address space of a process can be noncontiguous; process is allocated physical memory whenever the latter is available. 
	- Physical address space will also be noncontiguous
- Divide physical memory into fixed-sized blocks called FRAMES (size is poer of 2 )
- Divide logical memory into blocks of same size called PAGES
- Keep track of all free frames 
- To run a program of size n pages, need to find n free frames and load program 
- Set up a page table to translate to physical addresses 
- internal fragmentation 
- Each process has its own page table to translate to physical address 

=> physical memory set of fixed sized page frames  

ADDRESS TRANSLATION SCHEME (DONE BY THE HARDWARE)
Address generated by CPU is divided into; 

PAGE NUMBER(p) - used as an index into a page table which contains base address of each page in physical memory

PAGE OFFSET(d) - combined with base address to define the physical memory address that is sent to the memory unit 

	page number 	page offset 		
	     p		     d
	    m-n 	     n 

page table dan p. gozdeki deger main memorydeki asil page numaramizdir. Offset zaten AYNI.

- For given logical address space 2^m and page size is 2^n

	
IMPLEMENTATION OF PAGE TABLE 
- Page table is kept in main memory 
- PAGE TABLE BASE REGISTER (PTBR) points to the page table 
- PAGE TABLE LENGTH REGISTER (PTLR) indicates size of the page table 
- In the scheme every data/instruction access requires two memory accesses One for the page table and one for the data/instruction

- The two memory access problem can be solved by the use of a special fast-lookup hardware cache called ASSOCIATIVE MEMORY or TRANSLATION LOOK-ASIDE BUFFER (tlbs)

- Some TLB store address-space identifiers (ASIDs) in each TLB entry uniquely identifies each process to provide address space protection for that process

- Her process kendi page tablosuna sahipdtir.

- Accessing to TLB is much faster than PAGE TABLE. 



EFFECTIVE MEMORY ACCESS TIME 
- Associative Lookup = e time unit
- Assume memory cycle time is 1 microsecond 
- Hit ratio percentage of times that a page number is found in the associative registers; ratio related to number of associative registers 

- Hit ratio= a 
- Efective Access Time (EAT) 
	EAT = (1+e)a + (2+e)(1-e)
	    = 2+e-a	


MEMORY PROTECTION 
- Memory protection implemented by associating protection bit with each frame 

- VALID-INVALID bit attached to each entry in the page table 
- "valid" indicatex that the associated page is in the process' logical address space, and is thus a legal page 
- "invalid" indicates that the page is not in the process' logical address space 


SHARED PAGES 
- SHARED CODE 
 => One copy of read-only(reentrant) code shared among processes (text editors, compiler, window systems) 
 => Shared code must appear in same location in the logical address space of all processes 

- PRIVATE CODE AND DATA 
 => Each proces keeps a separate copy of the code and data 
 => The pages for the private code and data can appear anywhere in the logical address space 


STRUCTURE OF THE PAGE TABLE 
HIERARCHICAL PAGE TABLES 
- Break up the logical address space into multiple page tables 
- A simple techique is a two-level page table 


TWO-LEVEL PAGING EXAMPLE 
-> A logical address (on 32-bit machine with 1K page size) is divided into 
- a page number consisting of 22 bits 
- a page offset consisting of 10 bits 

-> Since the page table is paged the page number is further divided into 
- a 12 bit page number 
- a 10 bit page offset 
-> Thus logicalll address isa as follows: 

	page 		number 		page offset 
	p1 		p2	 	d 
	12 		10	 	10


Where P1 is an index into the outer page table and p2 is the displacement within the page of the outer page table. 

THREE - LEVEL PAGING SCHEMA 

outer page 	inner page 	offset 
p1		p2		d 
42		10		12 
 

2nd outer page 		outer page		inner page		offset
p1			p2			p3			d
32			10			10			12



HASHED PAGE TABLES 
- Common in address spaces > 32 bits 
- The virtual page number is hashed into a page table 
	- This page table contains a chain of elemants hashing to the same location 

- Virtual page numbers are compared in this chain searching for a match 
	- if a match is found the corresponding physical frame is extracted 



INVERTED PAGE TABLE 
- One entry for each real page of memory 
- Entry consists of the VIRTUAL ADDRESS OF THE PAGE stored in that real memory location with INFORMATION ABOUT THE PROCESS that owns that page. 
- Decreases memory needed to store each page table, but increases time needed to search the table when a pge reference occurs. 
- Use hash table to limit the search to one or at most a few page table entries 



SEGMENTATION 
-> Memory-management scheme that supports user view of memory 
-> A program is a collection of segments 
	-> A segment is a logical unit such as 
		- main program 
		- procedure
		- function
		- method 
		- object 
		- local variables, global variables 
		- common block 
		- stack 
		- symbol table 
		- arrays 
=> All segments could have different size in memory and they do not need to be contiguously placed to the memory. However one segment is contigious in itself. 

SEGMENTATION ARCHITECTURE 
-Logical address consists of a two tuple => SEGMENT NUMBER + OFFSET 

- SEGMENT TABLE -maps two dimensional logical addresses each table entry has 
	-base -> contains the starting physical address where the segments reside 		in memory 
	-limit -> specifies the length of the segment 

- Segment-table base register (STBR) points to the segment table's location in memory
- Segment-table length register (STLR) indicates number of segments used by a program. 
	=> segment number s is legal if s < STLR 

 
=> Segmentation can be used together with paging and fragmentation

SEGMENTATION ARCHITECTURE 
PROTECTION 
	- With each entry in segment table associate 
	- validation bit=0 => illegal segment 
	- read/write/execute privileges 

- Protection bits associated with segments; codes sharing occurs at segment level 
	- Code segment READONLY, sharable 
	- DATE segment READ-WRITE, not sharable 

- Since segments vary in length memory allocation is a dynamic storage allocation problem 



















































